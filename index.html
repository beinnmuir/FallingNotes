<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Notes</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: sans-serif;
            display: flex;
            flex-direction: column; /* Stack zones and button vertically */
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Allow container to fill available space */
            overflow: hidden; /* Keep dots contained */
        }

        .scale-zone {
            position: absolute;
            width: 100%;
            border-bottom: 1px solid #ccc;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Align label to the left */
            padding-left: 10px;
            font-size: 12px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.6);
            pointer-events: none; /* Allow clicks to pass through */
        }

        .dot {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
        }

        #controls {
            padding: 10px;
            background-color: #e0e0e0;
            text-align: center;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
        }

        #loop-toggle-button {
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
        }

        /* Pastel color classes removed - color set dynamically */

        #instructions {
            position: absolute;
            bottom: 10px;
            text-align: center;
            width: 100%;
            font-size: 0.9em;
            color: #a9a9a9; /* DarkGray */
            z-index: 1; /* Behind dots but above background */
        }

        /* Zone Styling */
        .zone-divider {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px; /* Horizontal line */
            background-color: rgba(176, 196, 222, 0.5); /* LightSteelBlue, semi-transparent */
            z-index: 0; /* Behind everything else */
        }

        .zone-label {
            position: absolute;
            left: 10px; /* Position from left edge */
            text-align: left;
            width: auto; /* Let content determine width */
            font-size: 0.8em;
            color: #b0c4de; /* LightSteelBlue */
            z-index: 1;
            pointer-events: none; /* Don't interfere with clicks */
            text-transform: capitalize;
        }

        /* Container for loop controls */
        #loop-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(230, 230, 230, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 8px; /* Spacing between elements */
            z-index: 100; /* Ensure it's above dots/zones */
        }

        #loop-controls button {
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid #aaa;
            border-radius: 3px;
            background-color: #f0f0f0;
            min-width: 80px; /* Ensure minimum width */
            text-align: center;
        }

        #loop-controls button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Style for the loop mode toggle and global actions */
        #loop-global-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Container for the dynamic list of loops */
        #loop-list-container {
            margin-top: 10px;
            max-height: 40vh; /* Limit height to 40% of viewport height */
            overflow-y: auto; /* Enable vertical scrollbar only when needed */
            -webkit-overflow-scrolling: touch; /* Optional: smoother scrolling on iOS */
            border: 1px solid #ddd; /* Light gray border */
            padding: 10px; /* Uniform padding */
            background-color: #f8f8f8; /* Light gray background */
            border-radius: 4px; /* Added rounded corners */
        }

        #loop-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .loop-item {
            background-color: #ffffff; /* White background for items */
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd; /* Consistent light gray border */
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .loop-item.selected {
            border-color: #4682b4; /* SteelBlue border when selected */
            background-color: rgba(220, 230, 240, 0.8);
        }

        .loop-item-header {
            font-weight: bold;
            font-size: 13px;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .loop-item-status {
            font-size: 10px;
            font-style: italic;
            color: #666;
        }

        .loop-item-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Two columns */
            gap: 5px;
        }

        /* Smaller buttons for per-loop actions */
        .loop-item-controls button {
            padding: 3px 6px;
            font-size: 11px;
            min-width: 60px;
        }

        #loop-actions {
            display: none;
        }

        /* Hide inner content, not the whole panel */
        #loop-panel-content.hidden {
            display: none !important; /* Ensure override on initial load */
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Dots will be added here -->
        <!-- Scale Zones will be added dynamically -->
    </div>

    <!-- Loop Controls Panel -->
    <div id="loop-controls">
        <button id="loop-mode-toggle">Enable Loop Mode</button>
        <!-- Inner container that gets hidden/shown -->
        <div id="loop-panel-content" class="hidden"> 
            <div id="loop-global-actions">
                <button id="play-button" disabled>Play All</button>
                <button id="add-loop-layer-button">Add Loop Layer</button>
                <button id="clear-all-loops-button" disabled>Clear All Loops</button>
                <button id="loop-sync-toggle" disabled>Async ON (click for Sync)</button>
            </div>
            <div id="loop-list-container">
                <ul id="loop-list">
                    <!-- Loop items will be generated here -->
                </ul>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('container');
        const body = document.body;
        let audioContext;
        // pastelColors array removed
        const activeDots = []; // Keep track of dots for animation
        let isDragging = false;
        let lastDragTime = 0;
        const dragThrottleInterval = 200; // Milliseconds between dot creation during drag

        // --- Looping State (Multi-track) ---
        let loopModeActive = false;
        let isRecording = false;
        let isPlaying = false;
        let allLoops = []; // Array of loop objects: [ { notes: [{note1}, {note2}], duration: T1 }, ... ] NEW STRUCTURE
        let currentLoopIndex = -1; // Index of the loop currently being selected/recorded
        let loopRecordStartTimes = {}; // { loopIndex: startTime }
        let loopPlaybackTimeouts = []; // Stores timeout IDs for stopping loop cycles
        let loopMutedStates = []; // Array of booleans, true if loop is muted
        let loopingMode = 'sync'; // 'sync' or 'async'
        let asyncLoopTimeouts = {}; // { loopIndex: timeoutId }
        const loopControlsPanel = document.getElementById('loop-controls');
        const loopModeToggleButton = document.getElementById('loop-mode-toggle');
        const loopPanelContent = document.getElementById('loop-panel-content'); // New inner container
        const loopListContainer = document.getElementById('loop-list-container');
        const loopList = document.getElementById('loop-list');
        // Global buttons
        const recordButton = document.getElementById('record-button');
        const playButton = document.getElementById('play-button');
        const addLoopLayerButton = document.getElementById('add-loop-layer-button');
        const clearAllLoopsButton = document.getElementById('clear-all-loops-button');
        const loopSyncToggleButton = document.getElementById('loop-sync-toggle');

        // --- Musical Scales Definition ---
        const baseFrequency = 65.4075; // C2
        const scales = {
            // Assigning distinct hues (0-360)
            major:       { name: 'major', intervals: [0, 2, 4, 5, 7, 9, 11], colorHue: 210 }, // Blue
            majPent:     { name: 'major pentatonic', intervals: [0, 2, 4, 7, 9], colorHue: 120 }, // Green
            blues:       { name: 'blues', intervals: [0, 3, 5, 6, 7, 10], colorHue: 270 }, // Purple
            natMinor:    { name: 'natural minor', intervals: [0, 2, 3, 5, 7, 8, 10], colorHue: 0 },   // Red
            harMinor:    { name: 'harmonic minor', intervals: [0, 2, 3, 5, 7, 8, 11], colorHue: 30 },  // Orange
            chromatic:   { name: 'chromatic', intervals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], colorHue: null } // Use greyscale
        };
        // Order can determine vertical position (top to bottom)
        const scaleOrder = ['major', 'majPent', 'blues', 'natMinor', 'harMinor', 'chromatic'];
        const numZones = scaleOrder.length;
        let zoneHeight = window.innerHeight / numZones;

        // --- Sound Setup ---
        async function initializeAudio() { 
            console.log('initializeAudio called');
            if (!audioContext) {
                try {
                    console.log('Creating new AudioContext');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Initial AudioContext state:', audioContext.state);
                    // Check if context is suspended and resume it (needed for mobile)
                    if (audioContext.state === 'suspended') {
                        console.log('Attempting to resume new suspended context...');
                        // Return the promise from resume()
                        return audioContext.resume().then(() => {
                            console.log('Context resumed successfully.', audioContext.state);
                        }).catch(err => {
                             console.error('Error resuming new context:', err);
                             throw err; // Re-throw error to be caught by caller
                        });
                    }
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser", e);
                    alert("Sorry, your browser doesn't support the Web Audio API needed for sound.");
                    return Promise.reject(e); // Return a rejected promise
                }
            } else if (audioContext.state === 'suspended') {
                console.log('Context exists but is suspended. Attempting to resume...');
                 // Return the promise from resume()
                return audioContext.resume().then(() => {
                    console.log('Existing context resumed successfully.', audioContext.state);
                }).catch(err => {
                    console.error('Error resuming existing context:', err);
                    throw err; // Re-throw error to be caught by caller
                });
            } else {
                console.log('AudioContext already exists and is running.', audioContext.state);
                // Context is ready, return a resolved promise
                return Promise.resolve(); 
            }
            // Ensure a resolved promise is returned if context was created and not suspended
            return Promise.resolve(); 
        }

        // --- Calculate Frequency from Scale Note ---
        function getFrequency(semitonesFromBase) {
            return baseFrequency * Math.pow(2, semitonesFromBase / 12);
        }

        // --- Play Note based on Scale and X-Position ---
        // Modified to accept optional startTime for scheduled playback
        function playNote(xPosition, scale, startTime = null) {
            console.log(`playNote called: x=${xPosition}, scale=${scale?.name}, startTime=${startTime}`);
            if (!audioContext || !scale) {
                console.warn('playNote aborted: No audioContext or scale.');
                return;
            }
            // We should now only reach here if context is running due to await in handlers
            // if (audioContext.state !== 'running') { 
            //    console.warn(`playNote called but audioContext is not running. State: ${audioContext.state}`);
            //    return; 
            // }

            // Normalize X across the entire screen width
            const relativeX = xPosition / window.innerWidth;

            const intervals = scale.intervals;
            // Map relativeX to an index in the scale's intervals array
            // Multiply by number of octaves desired across the screen width (e.g., 3)
            const octavesToSpan = 3;
            const totalNotesInSpan = intervals.length * octavesToSpan;
            const noteIndexOverall = Math.floor(relativeX * totalNotesInSpan);

            const noteIndexInScale = noteIndexOverall % intervals.length;
            const octaveShift = Math.floor(noteIndexOverall / intervals.length);

            const semitones = intervals[noteIndexInScale];
            const totalSemitones = semitones + (octaveShift * 12);

            const frequency = getFrequency(totalSemitones);

            console.log(`Attempting to play frequency: ${frequency}`);

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain(); // Re-enabled GainNode

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, startTime || audioContext.currentTime);

                // Use linear ramp and extend duration slightly for testing
                gainNode.gain.setValueAtTime(0.4, startTime || audioContext.currentTime); 
                gainNode.gain.linearRampToValueAtTime(0.001, (startTime || audioContext.currentTime) + 0.95); // Linear fade over ~1 sec

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                console.log('Oscillator connected via GainNode to destination');

                oscillator.start(startTime || audioContext.currentTime);
                // Restore original stop time
                oscillator.stop((startTime || audioContext.currentTime) + 1.0); // Extend to 1 second
                console.log('Oscillator started and scheduled to stop');
            } catch (err) {
                console.error('Error during oscillator creation/playback:', err);
            }
        }

        // --- Dot Creation ---
        function createDot(event) {
            const dot = document.createElement('div');
            dot.classList.add('dot');
            // Random color assignment removed

            const startX = event.clientX;
            const startY = event.clientY;
            dot.style.left = `${startX - 7}px`;
            dot.style.top = `${startY - 7}px`;

            // Determine scale based on vertical zone (Y position)
            const zoneIndex = Math.min(Math.floor(startY / zoneHeight), numZones - 1); // Ensure index is valid
            const scaleKey = scaleOrder[zoneIndex];
            const currentScale = scales[scaleKey];

            // --- Calculate Color based on Scale (Hue) and Pitch (Lightness) ---
            const normalizedX = startX / window.innerWidth; // 0 (left) to 1 (right)
            const minLightness = 40;
            const maxLightness = 80;
            // Reverse the lightness mapping: 0 (left) = maxLightness, 1 (right) = minLightness
            const lightness = maxLightness - (normalizedX * (maxLightness - minLightness));
            const saturation = 70; // Keep saturation constant for now

            let dotColor;
            if (currentScale.colorHue !== null) {
                // Use HSL for scales with assigned hues
                dotColor = `hsl(${currentScale.colorHue}, ${saturation}%, ${lightness}%)`;
            } else {
                // Use greyscale for chromatic (null hue)
                dotColor = `hsl(0, 0%, ${lightness}%)`;
            }
            dot.style.backgroundColor = dotColor;
            // --- End Color Calculation ---

            // --- Record Note if Recording ---
            if (isRecording && loopModeActive && currentLoopIndex >= 0 && allLoops[currentLoopIndex]) {
                const recordStartTime = loopRecordStartTimes[currentLoopIndex];
                if (recordStartTime !== undefined) {
                    const timestamp = audioContext.currentTime - recordStartTime;
                    const noteData = { timestamp, xPosition: startX, scale: currentScale };
                    allLoops[currentLoopIndex].notes.push(noteData);
                } else {
                    console.warn('No record start time found for current loop index:', currentLoopIndex);
                }
            }

            // --- Animation ---
            container.appendChild(dot);
            const fallDuration = 2000; // milliseconds
            const vy = 1.5 + Math.random() * 1.5;
            const dotInfo = {
                element: dot,
                x: startX,
                y: startY,
                vy,
                scale: currentScale // Store the scale for this dot
            };
            activeDots.push(dotInfo);
        }

        // --- Animation Loop ---
        function animate() {
            const bottomBoundary = window.innerHeight;

            for (let i = activeDots.length - 1; i >= 0; i--) {
                const dotInfo = activeDots[i];
                dotInfo.vy += 0.1;
                dotInfo.y += dotInfo.vy;
                dotInfo.element.style.top = `${dotInfo.y - 7}px`;

                if (dotInfo.y + 7.5 >= bottomBoundary) {
                    playNote(dotInfo.x, dotInfo.scale); // Pass X pos and scale info
                    container.removeChild(dotInfo.element);
                    activeDots.splice(i, 1);
                }
            }
            requestAnimationFrame(animate);
        }

        // --- UI Setup (Dividers and Labels) ---
        function setupScaleZones() {
            document.querySelectorAll('.zone-divider, .zone-label').forEach(el => el.remove());

            zoneHeight = window.innerHeight / numZones;

            for (let i = 1; i < numZones; i++) {
                // Add Horizontal Dividers
                const divider = document.createElement('div');
                divider.classList.add('zone-divider');
                divider.style.top = `${i * zoneHeight}px`; // Position based on height
                body.appendChild(divider);
            }

            for (let i = 0; i < numZones; i++) {
                // Add Labels (positioned vertically)
                const label = document.createElement('div');
                label.classList.add('zone-label');
                const scaleName = scales[scaleOrder[i]].name;
                const scaleHue = scales[scaleOrder[i]].colorHue;
                label.textContent = scaleName;
                // Center label vertically within its zone
                const labelY = (i * zoneHeight) + (zoneHeight / 2);
                label.style.top = `${labelY}px`;
                // Adjust for label height to truly center it
                label.style.transform = 'translateY(-50%)';
                // Optional: Color the label to match the zone hue
                if (scaleHue !== null) {
                    label.style.color = `hsl(${scaleHue}, 60%, 35%)`; // Darker, less saturated version of the hue
                }
                else {
                    label.style.color = `hsl(0, 0%, 40%)`; // Dark grey for chromatic
                }

                body.appendChild(label);
            }
        }

        // --- Event Listeners ---
        body.addEventListener('click', (event) => {
            // Ignore clicks inside the loop controls panel
            if (event.target.closest('#loop-controls')) return;

            if (!isDragging) { createDot(event); }
        });
        // Make the handler async
        container.addEventListener('mousedown', async (e) => {
            console.log('mousedown event fired');
            try {
                 // Wait for audio context to be ready
                await initializeAudio();
                console.log('Audio context ready after mousedown.');
            } catch (err) {
                 console.error('Failed to initialize audio on mousedown:', err);
                 return; // Don't proceed if audio failed
            }
            
            isDragging = true;
            createDot(e); // Create dot on initial click
            lastDragTime = Date.now();
        });

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const now = Date.now();
                if (now - lastDragTime > dragThrottleInterval) {
                    createDot(e);
                    lastDragTime = now;
                }
            }
        });

        container.addEventListener('mouseup', () => {
            isDragging = false;
        });

        container.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Make the handler async
        container.addEventListener('touchstart', async (e) => {
            console.log('touchstart event fired'); 
            // Prevent touch from ALSO triggering mousedown/click events immediately
            e.preventDefault(); 

            try {
                // Wait for audio context to be ready
                await initializeAudio(); 
                console.log('Audio context ready after touchstart.');
            } catch (err) {
                console.error('Failed to initialize audio on touchstart:', err);
                return; // Don't proceed if audio failed
            }

            isDragging = true;
            // Get touch coordinates
            const touch = e.touches[0]; 
            const mockEvent = { clientX: touch.clientX, clientY: touch.clientY };
            createDot(mockEvent); 
            lastDragTime = Date.now();
        }, { passive: false }); // Need passive: false to allow preventDefault

        container.addEventListener('touchmove', (e) => {
            if (isDragging) {
                // Prevent scrolling while dragging to create notes
                e.preventDefault(); 

                const now = Date.now();
                if (now - lastDragTime > dragThrottleInterval) {
                    const touch = e.touches[0];
                    const mockEvent = { clientX: touch.clientX, clientY: touch.clientY };
                    createDot(mockEvent);
                    lastDragTime = now;
                }
            }
        }, { passive: false }); // Need passive: false to allow preventDefault

        container.addEventListener('touchend', (e) => {
            // Check if touches list is empty (last finger lifted)
             if (e.touches.length === 0) {
                isDragging = false;
            }
            // Optional: Prevent default actions if needed
            // e.preventDefault(); 
        });

        window.addEventListener('resize', () => {
            setupScaleZones();
        });

        // --- Loop Control Event Listeners ---
        // Listener for dynamically generated buttons within the loop list
        if (loopList) { // Ensure loopList exists before adding listener
            loopList.addEventListener('click', (event) => {
                if (!loopModeActive) return;
                const target = event.target;
                const loopItem = target.closest('.loop-item');
                if (!loopItem) return;

                const index = parseInt(loopItem.dataset.loopIndex, 10);
                if (isNaN(index) || index < 0 || index >= allLoops.length) return;

                let handled = false;

                if (target.classList.contains('loop-select-button')) {
                    console.log(`Selecting loop ${index + 1}`);
                    currentLoopIndex = index;
                    if (isRecording) { // Stop recording if selecting a different loop
                        stopRecording();
                    }
                    updateLoopUI();
                    handled = true;
                } else if (target.classList.contains('loop-record-button')) {
                    if (index !== currentLoopIndex) {
                        console.log("Select loop before recording.");
                        return; // Must select first
                    }
                    toggleRecording(index);
                    updateLoopUI();
                    handled = true;
                } else if (target.classList.contains('loop-mute-button')) {
                    loopMutedStates[index] = !loopMutedStates[index];
                    console.log(`Loop ${index + 1} muted: ${loopMutedStates[index]}`);
                    updateLoopUI();
                    handled = true;
                } else if (target.classList.contains('loop-clear-button')) {
                    console.log(`Clearing loop ${index + 1}`);
                    if (isPlaying && loopingMode === 'async' && asyncLoopTimeouts[index]) {
                        console.log(`Clearing async timeout for cleared loop ${index + 1}`);
                        clearTimeout(asyncLoopTimeouts[index]);
                        delete asyncLoopTimeouts[index];
                        // Check if any other async loops are still running
                        if (Object.keys(asyncLoopTimeouts).length === 0) {
                            console.log('Last async loop cleared, stopping playback.');
                            stopAllLoops(); // Stop playback if the last running async loop was cleared
                        }
                    }
                    if (isRecording && currentLoopIndex === index) {
                        stopRecording(); // Stop if clearing the loop being recorded
                    }
                    // Reset the loop object
                    allLoops[index] = { notes: [], duration: 0 };

                    if (allLoops.every(loop => loop.notes.length === 0)) {
                        stopAllLoops(); // Stop playback if all loops are now empty
                    }
                    updateLoopUI();
                    handled = true;
                }

                if (handled) {
                    event.stopPropagation(); // Prevent body listener from firing
                }
            });
        } else {
            console.error("#loop-list element not found!");
        }

        // Single button to toggle the entire loop panel visibility and active state
        loopModeToggleButton.addEventListener('click', () => {
            if (!audioContext) initializeAudio();
            if (!audioContext) return; // Still couldn't get it

            loopModeActive = !loopModeActive; // Toggle the active state
            console.log(`Loop mode toggled. Active: ${loopModeActive}`);

            if (loopModeActive) {
                // Add the first loop layer automatically if none exist
                if (allLoops.length === 0) {
                    console.log("Loop mode enabled, adding initial loop layer.");
                    addEmptyLoop();
                }
            } else {
                // Disabling loop mode - stop everything related to looping
                if (isPlaying) {
                    console.log("Disabling loop mode, stopping playback.");
                    stopAllLoops();
                }
                if (isRecording) {
                    stopRecording(); // stopRecording handles logging
                }
            }

            updateLoopUI(); // Update UI based on new state (will show/hide panel)
        });

        addLoopLayerButton.addEventListener('click', () => {
            if (!loopModeActive) return;
            if (isRecording) {
                // Stop recording current loop before adding a new one
                stopRecording();
            }
            addEmptyLoop();
            updateLoopUI();
        });

        playButton.addEventListener('click', () => {
            if (!loopModeActive) return;

            if (isPlaying) {
                console.log("Play Button Clicked: Stopping playback.");
                // Stop playing
                stopAllLoops(); // This sets isPlaying = false and calls updateLoopUI
            } else if (allLoops.length > 0 && allLoops.some(loop => loop.notes.length > 0)) {
                console.log("Play Button Clicked: Starting playback.");
                // Start Playing
                isPlaying = true;           // Set state
                updateLoopUI();             // Update button text immediately
                console.log("Clearing previous timeouts before starting...");
                if (loopingMode === 'sync') {
                    loopPlaybackTimeouts.forEach(timeoutId => clearTimeout(timeoutId)); // Clear old timeouts before starting
                    loopPlaybackTimeouts = [];
                    console.log("Starting first sync loop cycle.");
                    runLoopCycle();             // Start the first sync cycle
                } else { // async mode
                    Object.values(asyncLoopTimeouts).forEach(clearTimeout);
                    asyncLoopTimeouts = {};
                    console.log("Starting individual async loop cycles.");
                    allLoops.forEach((loop, index) => {
                        if (loop.notes.length > 0 && !loopMutedStates[index]) {
                            console.log(`Initiating async cycle for loop ${index + 1}`);
                            playSingleLoopAsync(index);
                        }
                    });
                }
            } else {
                console.log("Play Button Clicked: No loops with notes to play.");
            }
        });

        clearAllLoopsButton.addEventListener('click', () => {
            console.log("Clear All Loops Button Clicked.");
            stopAllLoops(); // Stop playback first
            stopRecording(); // Ensure recording is stopped
            
            // Clear all loop data and related states
            allLoops = []; 
            loopMutedStates = [];
            currentLoopIndex = -1; // Reset selected index
            loopRecordStartTimes = {}; // Clear recording start times
            // No need to manually clear asyncLoopTimeouts, stopAllLoops handles it.

            // Add one initial empty loop layer back
            addEmptyLoop(); 
            
            console.log("All loops cleared. Added one new empty loop.");
            updateLoopUI(); // Update UI immediately
        });

        // NEW: Sync/Async Toggle Listener
        loopSyncToggleButton.addEventListener('click', () => {
            if (isPlaying || isRecording) {
                console.log("Cannot change loop mode while playing or recording.");
                return;
            }
            loopingMode = (loopingMode === 'sync') ? 'async' : 'sync';
            console.log(`Loop mode changed to: ${loopingMode}`);
            // Update button text immediately
            loopSyncToggleButton.textContent = loopingMode === 'sync' ? 'Sync ON (click for Async)' : 'Async ON (click for Sync)';
            updateLoopUI(); // Reflect potential state changes in UI (though text is already updated)
        });

        // --- Loop Functions ---
        function addEmptyLoop() {
            const newIndex = allLoops.length;
            // Initialize with new structure
            allLoops.push({ notes: [], duration: 0 });
            loopMutedStates.push(false); // Add mute state (default: not muted)
            currentLoopIndex = newIndex; // Select the new loop
            console.log(`Added new loop layer. Now on loop ${currentLoopIndex + 1}.`);
            // updateLoopUI() will be called after this function finishes
        }

        function finalizeLoop(index) {
            const recordStartTime = loopRecordStartTimes[index];
            if (index >= 0 && index < allLoops.length && recordStartTime !== undefined) {
                const loopData = allLoops[index]; // Get object
                
                loopData.notes.sort((a, b) => a.timestamp - b.timestamp); // Sort notes
                
                // NEW: Calculate duration based on the last note's timestamp
                let effectiveDuration = 0.5; // Default minimum duration
                if (loopData.notes.length > 0) {
                    const lastNoteTimestamp = loopData.notes[loopData.notes.length - 1].timestamp;
                    // Ensure duration is at least the minimum
                    effectiveDuration = Math.max(lastNoteTimestamp, 0.5);
                }
                
                loopData.duration = effectiveDuration;
                
                console.log(`Finalized loop ${index + 1}. Duration (last note): ${loopData.duration.toFixed(3)}s, Notes: ${loopData.notes.length}`);
                
                delete loopRecordStartTimes[index]; // Clear start time once recording stops
            } else {
                console.warn(`finalizeLoop: Could not finalize loop ${index}, invalid index or start time missing.`);
            }
        }

        function stopRecording() { // Utility to ensure recording stops
            if (isRecording) {
                isRecording = false;
                finalizeLoop(currentLoopIndex);
                updateLoopUI();
                console.log("Recording force stopped.")
            }
        }

        function toggleRecording(index) {
            if (index !== currentLoopIndex) return; // Should only toggle for selected loop

            isRecording = !isRecording;
            if (isRecording) {
                // Start recording
                loopRecordStartTimes[index] = audioContext.currentTime;
                // Clear previous data and reset duration for this loop object
                allLoops[index] = { notes: [], duration: 0 };
                console.log(`Recording started for loop ${index + 1}...`);
            } else {
                // Stop recording
                finalizeLoop(index); // finalize now calculates and stores duration
                console.log(`Recording stopped for loop ${index + 1}.`); // Note count logged in finalizeLoop
            }
        }

        function runLoopCycle() {
            // This function remains the handler for SYNC mode playback
            if (!loopModeActive || !isPlaying || loopingMode !== 'sync') {
                console.log("runLoopCycle: Stopping (inactive, stopped, or not sync mode).");
                if (isPlaying) stopAllLoops(); // Stop if conditions aren't met but was playing
                return;
            }

            // Check if playback was stopped externally since the timeout was scheduled
            if (!isPlaying) {
                console.log("runLoopCycle: Stopping because isPlaying is false.");
                return; // Don't run the cycle if stopAllLoops was called
            }

            console.log(`Running loop cycle... (isPlaying: ${isPlaying})`);
            const globalPlaybackStartTime = audioContext.currentTime;
            let maxDuration = 0;

            allLoops.forEach((loop, index) => {
                // Use loopData object
                if (loop.notes.length === 0 || loopMutedStates[index]) {
                    console.log(`Skipping loop ${index+1} (muted: ${loopMutedStates[index]}, length: ${loop.notes.length})`);
                    return; // Skip empty or muted loops
                }

                // Schedule notes from loop.notes
                loop.notes.forEach(note => {
                    const playTime = globalPlaybackStartTime + note.timestamp;
                    playNote(note.xPosition, note.scale, playTime);
                });

                // Find the maximum *stored* duration among active loops
                if (loop.duration > maxDuration) {
                    maxDuration = loop.duration;
                }
            });

            // Schedule the *next* cycle based on the longest loop's stored duration
            if (maxDuration > 0 && isPlaying) { // Add isPlaying check here before scheduling next
                console.log(`Sync mode: Scheduling next loop cycle in ${maxDuration.toFixed(3)}s`);
                const timeoutId = setTimeout(runLoopCycle, maxDuration * 1000);
                loopPlaybackTimeouts.push(timeoutId);
            } else if (isPlaying) { // Only log/stop if we were intending to play (and in sync mode)
                console.log("Sync loop cycle ended, but no notes found/played. Stopping.");
                stopAllLoops(); // Stop playback if maxDuration is 0 or only muted loops exist
            } else {
                console.log("runLoopCycle: Playback stopped during cycle execution.")
            }
        }

        // NEW: Function to handle a single loop cycle in async mode
        function playSingleLoopAsync(index) {
            const loopData = allLoops[index]; // Get loop object

            // Check conditions on each async cycle start, using loopData
            if (!loopModeActive || !isPlaying || loopingMode !== 'async' || index < 0 || index >= allLoops.length || loopMutedStates[index] || loopData.notes.length === 0) {
                console.log(`playSingleLoopAsync(${index}): Stopping loop (inactive, stopped, not async, muted, or empty).`);
                if (asyncLoopTimeouts[index]) {
                    clearTimeout(asyncLoopTimeouts[index]);
                    delete asyncLoopTimeouts[index];
                }
                // Check if this was the last running loop
                if (isPlaying && loopingMode === 'async' && Object.keys(asyncLoopTimeouts).length === 0) {
                    console.log(`Last active async loop (${index}) finished/stopped. Stopping all playback.`);
                    stopAllLoops(); // Stop all if the last one finished its cycle
                }
                return;
            }

            const loop = loopData.notes; // Get notes array
            const loopDuration = loopData.duration; // Use stored duration
            const loopStartTime = audioContext.currentTime;
            console.log(`playSingleLoopAsync(${index}): Starting cycle at ${loopStartTime.toFixed(3)}, duration: ${loopDuration.toFixed(3)}s`);

            // Enforce a minimum duration of 0.5 seconds for better usability
            const effectiveDuration = Math.max(loopDuration, 0.5);

            // Iterate over notes array
            loop.forEach(note => {
                const playTime = loopStartTime + note.timestamp;
                playNote(note.xPosition, note.scale, playTime);
            });

            // Clear previous timeout for this specific loop *before* setting a new one
            if (asyncLoopTimeouts[index]) {
                clearTimeout(asyncLoopTimeouts[index]);
                delete asyncLoopTimeouts[index]; // Ensure we delete before setting a new one
            }

            if (effectiveDuration > 0) {
                console.log(`playSingleLoopAsync(${index}): Scheduling next cycle in ${effectiveDuration.toFixed(3)}s`);
                const timeoutId = setTimeout(() => {
                    // Verify the timeout is still valid before proceeding
                    if (asyncLoopTimeouts[index] === timeoutId) {
                        playSingleLoopAsync(index);
                    }
                }, effectiveDuration * 1000);
                asyncLoopTimeouts[index] = timeoutId;
            } else {
                // This case should be less likely now as finalizeLoop sets a minimum duration
                console.log(`playSingleLoopAsync(${index}): Loop duration is 0 or invalid, not rescheduling.`);
                delete asyncLoopTimeouts[index]; // Remove from active timeouts
                // Check if this was the last running loop
                if (isPlaying && loopingMode === 'async' && Object.keys(asyncLoopTimeouts).length === 0) {
                    console.log(`Last active async loop (${index}) finished (duration 0). Stopping all playback.`);
                    stopAllLoops();
                }
            }
        }

        function stopAllLoops() {
            console.log('stopAllLoops called.');
            const wasPlaying = isPlaying; // Check if it was actually playing
            isPlaying = false; // Set state *before* UI update

            // Clear Sync Timers
            console.log(`Clearing ${loopPlaybackTimeouts.length} sync loop cycle timeouts.`);
            loopPlaybackTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            loopPlaybackTimeouts = [];

            // Clear Async Timers
            const asyncCount = Object.keys(asyncLoopTimeouts).length;
            console.log(`Clearing ${asyncCount} async loop cycle timeouts.`);
            Object.values(asyncLoopTimeouts).forEach(timeoutId => clearTimeout(timeoutId));
            asyncLoopTimeouts = {};

            console.log('Cleared upcoming loop cycles.');
            // Update UI if the mode is active OR if it was playing (to reset button text)
            if(loopModeActive || wasPlaying) {
                console.log('Updating UI after stopping.');
                updateLoopUI(); // Update UI AFTER state change
            }
        }

        // --- UI Update Function ---
        function updateLoopUI() {
            if (!loopControlsPanel) return; // Ensure elements exist

            console.log(`updateLoopUI called. loopModeActive: ${loopModeActive}, isPlaying: ${isPlaying}, isRecording: ${isRecording}, loopingMode: ${loopingMode}`);

            if (loopModeActive) {
                console.log('updateLoopUI: Removing hidden class from panel content.');
                loopPanelContent.classList.remove('hidden'); // Show inner content
                loopModeToggleButton.textContent = 'Disable Loop Mode'; // Text when panel is visible

                const hasAnyLoops = allLoops.length > 0;
                // Check notes array length
                const hasNotesInAnyLoop = hasAnyLoops && allLoops.some(loop => loop.notes.length > 0);

                // Update Global Buttons
                playButton.disabled = !hasNotesInAnyLoop || isRecording;
                playButton.textContent = isPlaying ? 'Stop' : 'Play All';

                addLoopLayerButton.disabled = isRecording;

                clearAllLoopsButton.disabled = !hasAnyLoops || isRecording || isPlaying;

                // NEW: Update Sync/Async toggle button
                loopSyncToggleButton.textContent = loopingMode === 'sync' ? 'Sync ON (click for Async)' : 'Async ON (click for Sync)';
                loopSyncToggleButton.disabled = isPlaying || isRecording;

                // Update Loop List
                loopList.innerHTML = ''; // Clear previous list items
                allLoops.forEach((loopData, index) => {
                    const li = document.createElement('li');
                    li.classList.add('loop-item');
                    li.dataset.loopIndex = index;
                    if (index === currentLoopIndex) {
                        li.classList.add('selected');
                    }

                    const loop = loopData.notes; // Get notes array
                    const isMuted = loopMutedStates[index];
                    const loopHasData = loop.length > 0;
                    const isCurrentlyRecordingThis = isRecording && currentLoopIndex === index;
                    const displayDuration = loopData.duration > 0 ? `${loopData.duration.toFixed(1)}s` : '(empty)'; // Show duration

                    li.innerHTML = `
                        <div class="loop-item-header">
                            <span>Loop ${index + 1}</span>
                            <span class="loop-item-status">
                                ${isCurrentlyRecordingThis ? 'RECORDING' : (loopHasData ? `${loop.length} notes / ${displayDuration}` : '(empty)')}
                                ${isMuted ? ' [MUTED]' : ''}
                            </span>
                        </div>
                        <div class="loop-item-controls">
                            <button class="loop-select-button" ${index === currentLoopIndex ? 'disabled' : ''}>Select</button>
                            <button class="loop-record-button" ${index !== currentLoopIndex ? 'disabled' : ''}>${isCurrentlyRecordingThis ? 'Stop Rec' : 'Record'}</button>
                            <button class="loop-mute-button" ${!loopHasData ? 'disabled' : ''}>${isMuted ? 'Unmute' : 'Mute'}</button>
                            <button class="loop-clear-button" ${!loopHasData ? 'disabled' : ''}>Clear</button>
                        </div>
                    `;
                    loopList.appendChild(li);
                });
            } else {
                console.log('updateLoopUI: Adding hidden class to panel content.');
                loopPanelContent.classList.add('hidden'); // Hide inner content
                loopModeToggleButton.textContent = 'Enable Loop Mode';
                // Ensure playback/recording stops if mode is disabled
                if (isPlaying) stopAllLoops();
                if (isRecording) stopRecording(); // stopRecording handles logging

                // Ensure Sync/Async toggle is also hidden or appropriately handled
                // It's inside loopPanelContent, so it gets hidden automatically.
                // Reset its state if needed when mode is disabled?
                // loopingMode = 'sync'; // Optionally reset mode on disable?
            }
        }

        // Initial Setup
        setupScaleZones();
        console.log(`Initial check before first updateLoopUI: loopModeActive = ${loopModeActive}`);
        updateLoopUI(); // Initial UI state
        requestAnimationFrame(animate);
    </script>
</body>
</html>
